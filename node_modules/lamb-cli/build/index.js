#!/usr/bin/env node
"use strict";
/**
 * CLI Tool
 *
 * lamb-cli init
 * lamb-cli push
 * lamb-cli create
 * lamb-cli delete
 *
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const inquirer_1 = __importDefault(require("inquirer"));
const path_1 = __importDefault(require("path"));
const config_1 = require("./config");
const lambda_1 = require("./lambda");
const lambda_local_1 = require("./lambda-local");
const log_1 = require("./log");
const metadata_1 = require("./metadata");
const push_1 = require("./push");
const zip_1 = require("./zip");
(() => __awaiter(void 0, void 0, void 0, function* () {
    const program = new commander_1.Command();
    const metadata = yield metadata_1.Metadata.init({
        filePath: path_1.default.resolve(process.cwd(), "lamb-cli.config.json"),
    });
    program
        .name(yield config_1.config.cliName)
        .description(yield config_1.config.description)
        .version(yield config_1.config.cliVersion);
    program
        .command("push")
        .description("Will bundle and push the code to server")
        .action(() => __awaiter(void 0, void 0, void 0, function* () {
        const choices = (yield config_1.config.metadata).functions;
        if (choices.length === 0) {
            (0, log_1.logError)(`No function found. Consider adding one with ${config_1.config.cliName} add`);
            return;
        }
        const { fnName } = yield inquirer_1.default.prompt([
            {
                message: "Which function do you wanna push",
                type: "list",
                name: "fnName",
                choices: choices,
            },
        ]);
        const fn = yield metadata_1.functions.get(fnName);
        if (!fn) {
            (0, log_1.logError)("No Function found");
            return;
        }
        yield (0, push_1.push)({
            region: fn.region,
            functionArn: fn.arn,
            zipBuffer: yield (0, zip_1.createZipBuffer)({
                entry: path_1.default.resolve(config_1.config.workingPath, fn.entryFile),
            }),
        });
        console.log("Done");
    }));
    program
        .command("init")
        .description("Initialize the configuration file")
        .action(() => __awaiter(void 0, void 0, void 0, function* () {
        yield config_1.config.metadata;
    }));
    program
        .command("add")
        .description("Add lambda function details")
        .action(() => __awaiter(void 0, void 0, void 0, function* () {
        const answers = yield inquirer_1.default.prompt([
            {
                message: "Function Name? (Only used in your local project)",
                type: "input",
                name: "name",
                validate: (name) => __awaiter(void 0, void 0, void 0, function* () {
                    if (yield metadata_1.functions.get(name))
                        return "Name is taken";
                    return true;
                }),
            },
            {
                message: "Function ARN",
                type: "input",
                name: "arn",
            },
            {
                message: "Function Region",
                type: "input",
                name: "region",
            },
            {
                message: "Entry file path",
                type: "input",
                name: "entryFile",
            },
        ]);
        yield metadata_1.functions.add(answers);
    }));
    program
        .command("create")
        .description("Creates a lambda function in the server and gives you the boilerplate code")
        .action(() => __awaiter(void 0, void 0, void 0, function* () {
        const answers = yield inquirer_1.default.prompt([
            {
                type: "input",
                message: "Function Name: ",
                name: "name",
            },
            {
                type: "confirm",
                message: "Wanna use typescript? ",
                name: "useTypescript",
            },
            {
                type: "input",
                message: "Function Region: ",
                name: "region",
            },
            {
                type: "confirm",
                message: "Do you want put entryFile in a folder? ",
                name: "hasFolderPath",
            },
            {
                type: "input",
                message: "Mention the folder path: ",
                name: "folderPath",
                when: (answers) => answers.hasFolderPath,
            },
        ]);
        const { region, name, folderPath = "", useTypescript } = answers;
        const createExecution = new lambda_1.CreateExecution({
            region: answers.region,
        });
        const lambdaLocal = new lambda_local_1.LambdaLocal({
            projectRoot: process.cwd(),
        });
        const srcFile = yield lambdaLocal.createEntryFile({
            filename: name,
            typescript: useTypescript,
            dir: folderPath,
        });
        const { FunctionArn, RoleName } = yield createExecution.execute({
            name,
            unit8ArrayBuffer: yield lambdaLocal.getZipUnit8Array({
                entryFile: srcFile,
            }),
        });
        yield metadata.addFunction({
            arn: FunctionArn,
            entryFile: srcFile,
            name,
            region,
            roleName: RoleName,
        });
    }));
    program
        .command("delete")
        .description("To delete the function created by the cli")
        .action(() => __awaiter(void 0, void 0, void 0, function* () {
        const fns = yield metadata.getFunctions();
        if (fns.length === 0) {
            (0, log_1.logError)("No function created by the cli");
            return;
        }
        const { fnName } = yield inquirer_1.default.prompt([
            {
                type: "list",
                message: "Choose the function: ",
                name: "fnName",
                choices: fns.map((f) => f.name),
            },
        ]);
        const fn = fns.find((f) => f.name === fnName);
        yield new lambda_1.DeleteExecution({
            region: fn.region,
        }).execute({
            FunctionArn: fn.arn,
            RoleName: fn.roleName,
        });
        yield metadata.removeFunction(fnName);
    }));
    program.parse();
}))();
